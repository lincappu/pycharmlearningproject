# !/usr/bin/env python3
# _*_coding:utf-8_*_

# 第一次import 会执行了原文件的代码，
#
# import 干了三件事：
# 1.为源代码文件中定义的对象创建一个名字空间，通过这个名字空间可以访问到模块中定义的函数及变量。
# 2.在新创建的名字空间里执行源代码文件.
# 3.创建一个名为源代码文件的对象，该对象引用模块的名字空间，这样就可以通过这个对象访问模块中的函数及变量
#
#
# 1.被导入的变量与方法，有独立的名称空间，不会与现在的冲突
# 2.可以为模块起别名。
# 3.可以一行导入多个模块。
# 4.from ...import  可以直接将变量和方法导入到名称空间中，有好处也有坏处，也支持 as
# 使用from语句可以将模块中的对象直接导入到当前的名字空间. from语句不创建一个到模块名字空间的引用对象，而是把被导入模块的一个或多个对象直接放入当前的名字空间:
# 5.可以种__all__=[]来控制导入的名称空间的变量和方法,是用 from name import * 时导入的功能。 在原文件中引用。

# import m  as s
#
#
# s.foo()

# from  m import  foo
#
# foo()


# from m  import  *
#
#
# foo()
# bar()


# import 语句可以在程序的任何位置使用，你可以在程序中多次导入同一个模块，但模块中的代码*仅仅*在该模块被首次导入时执行。后面的import语句只是简单的创建一个到模块名字空间的引用而已。sys.modules字典中保存着所有被导入模块的模块名到模块对象的映射。这个字典用来决定是否需要使用import语句来导入一个模块的最新拷贝.



# 模块重载：
# 使用模块的功能，只能重新打开程序，importlib这个不建议使用。
# import  importlib
# importlib.reload()
#



# 区分py 文件的用途： 模块还是脚本
# import m
# print(m.__name__)
# __name__
# 如果是在函数内部调用，这个变量值是__main__
# 如果是在导入的包中引用，这个值是函数名，由这个值来控制程序是否执行。

# if __name__ == '__main__':
#     main()




















